// The dollar sign means "do the specialization with these arguments when the function is called"
def compile(val expr :: Expr) -> (Int => Int) $=> (val arg :: Int) -> Int => eval(expr, arg);

def main() {
    val src = readline();
    val expr = parse(src);
    val calc = compile(expr);

    // Now we can evaluate this function a bunch without paying the interpretation
    // penalty every time!
    val total = 0;
    for var i = 0; i < 1000000000; set i = i + 1 {
        set total = total + calc(i);
    }

    print("Total from zero to a billion: "  + total );
}

// Simple AST, parser, and tree-walking interpreter for single-arg functions.
type Expr \Add;
def parse(val src :: String) -> Expr { /* ... */ }
def eval(val expr :: Expr, val arg :: Int) -> Int {
    case expr = Expr\Add(val a, val b) {
        eval(a) + eval(b)
    } else expr = Expr\Mul(val a, val b) {
        eval(a) * eval(b)
    } else expr = Expr\Neg(val a) {
        -eval(a)
    }  else expr = Expr\Const(val i) {
        i
    } else expr = Expr\Arg {
        arg
    }
}
